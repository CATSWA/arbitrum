/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from 'ethers';
import { Listener, Provider } from 'ethers/providers';
import { Arrayish, BigNumber, BigNumberish, Interface } from 'ethers/utils';
import { TransactionOverrides, TypedEventDescription, TypedFunctionDescription } from '.';

interface ArbERC721Interface extends Interface {
    functions: {
        supportsInterface: TypedFunctionDescription<{
            encode([interfaceId]: [Arrayish]): string;
        }>;

        getApproved: TypedFunctionDescription<{
            encode([tokenId]: [BigNumberish]): string;
        }>;

        approve: TypedFunctionDescription<{
            encode([to, tokenId]: [string, BigNumberish]): string;
        }>;

        totalSupply: TypedFunctionDescription<{ encode([]: []): string }>;

        transferFrom: TypedFunctionDescription<{
            encode([from, to, tokenId]: [string, string, BigNumberish]): string;
        }>;

        tokenOfOwnerByIndex: TypedFunctionDescription<{
            encode([owner, index]: [string, BigNumberish]): string;
        }>;

        safeTransferFrom: TypedFunctionDescription<{
            encode([from, to, tokenId]: [string, string, BigNumberish]): string;
        }>;

        tokenByIndex: TypedFunctionDescription<{
            encode([index]: [BigNumberish]): string;
        }>;

        ownerOf: TypedFunctionDescription<{
            encode([tokenId]: [BigNumberish]): string;
        }>;

        balanceOf: TypedFunctionDescription<{ encode([owner]: [string]): string }>;

        setApprovalForAll: TypedFunctionDescription<{
            encode([to, approved]: [string, boolean]): string;
        }>;

        isApprovedForAll: TypedFunctionDescription<{
            encode([owner, operator]: [string, string]): string;
        }>;

        tokensOfOwner: TypedFunctionDescription<{
            encode([owner]: [string]): string;
        }>;

        adminMint: TypedFunctionDescription<{
            encode([account, tokenId]: [string, BigNumberish]): string;
        }>;

        withdraw: TypedFunctionDescription<{
            encode([account, tokenId]: [string, BigNumberish]): string;
        }>;
    };

    events: {
        Transfer: TypedEventDescription<{
            encodeTopics([from, to, tokenId]: [string | null, string | null, BigNumberish | null]): string[];
        }>;

        Approval: TypedEventDescription<{
            encodeTopics([owner, approved, tokenId]: [string | null, string | null, BigNumberish | null]): string[];
        }>;

        ApprovalForAll: TypedEventDescription<{
            encodeTopics([owner, operator, approved]: [string | null, string | null, null]): string[];
        }>;
    };
}

export class ArbERC721 extends Contract {
    connect(signerOrProvider: Signer | Provider | string): ArbERC721;
    attach(addressOrName: string): ArbERC721;
    deployed(): Promise<ArbERC721>;

    on(event: EventFilter | string, listener: Listener): ArbERC721;
    once(event: EventFilter | string, listener: Listener): ArbERC721;
    addListener(eventName: EventFilter | string, listener: Listener): ArbERC721;
    removeAllListeners(eventName: EventFilter | string): ArbERC721;
    removeListener(eventName: any, listener: Listener): ArbERC721;

    interface: ArbERC721Interface;

    functions: {
        supportsInterface(interfaceId: Arrayish): Promise<boolean>;

        getApproved(tokenId: BigNumberish): Promise<string>;

        approve(to: string, tokenId: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

        totalSupply(): Promise<BigNumber>;

        transferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: TransactionOverrides,
        ): Promise<ContractTransaction>;

        tokenOfOwnerByIndex(owner: string, index: BigNumberish): Promise<BigNumber>;

        safeTransferFrom(
            from: string,
            to: string,
            tokenId: BigNumberish,
            overrides?: TransactionOverrides,
        ): Promise<ContractTransaction>;

        tokenByIndex(index: BigNumberish): Promise<BigNumber>;

        ownerOf(tokenId: BigNumberish): Promise<string>;

        balanceOf(owner: string): Promise<BigNumber>;

        setApprovalForAll(
            to: string,
            approved: boolean,
            overrides?: TransactionOverrides,
        ): Promise<ContractTransaction>;

        isApprovedForAll(owner: string, operator: string): Promise<boolean>;

        tokensOfOwner(owner: string): Promise<BigNumber[]>;

        adminMint(
            account: string,
            tokenId: BigNumberish,
            overrides?: TransactionOverrides,
        ): Promise<ContractTransaction>;

        withdraw(
            account: string,
            tokenId: BigNumberish,
            overrides?: TransactionOverrides,
        ): Promise<ContractTransaction>;
    };

    supportsInterface(interfaceId: Arrayish): Promise<boolean>;

    getApproved(tokenId: BigNumberish): Promise<string>;

    approve(to: string, tokenId: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

    totalSupply(): Promise<BigNumber>;

    transferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    tokenOfOwnerByIndex(owner: string, index: BigNumberish): Promise<BigNumber>;

    safeTransferFrom(
        from: string,
        to: string,
        tokenId: BigNumberish,
        overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    tokenByIndex(index: BigNumberish): Promise<BigNumber>;

    ownerOf(tokenId: BigNumberish): Promise<string>;

    balanceOf(owner: string): Promise<BigNumber>;

    setApprovalForAll(to: string, approved: boolean, overrides?: TransactionOverrides): Promise<ContractTransaction>;

    isApprovedForAll(owner: string, operator: string): Promise<boolean>;

    tokensOfOwner(owner: string): Promise<BigNumber[]>;

    adminMint(account: string, tokenId: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

    withdraw(account: string, tokenId: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

    filters: {
        Transfer(from: string | null, to: string | null, tokenId: BigNumberish | null): EventFilter;

        Approval(owner: string | null, approved: string | null, tokenId: BigNumberish | null): EventFilter;

        ApprovalForAll(owner: string | null, operator: string | null, approved: null): EventFilter;
    };

    estimate: {
        supportsInterface(interfaceId: Arrayish): Promise<BigNumber>;

        getApproved(tokenId: BigNumberish): Promise<BigNumber>;

        approve(to: string, tokenId: BigNumberish): Promise<BigNumber>;

        totalSupply(): Promise<BigNumber>;

        transferFrom(from: string, to: string, tokenId: BigNumberish): Promise<BigNumber>;

        tokenOfOwnerByIndex(owner: string, index: BigNumberish): Promise<BigNumber>;

        safeTransferFrom(from: string, to: string, tokenId: BigNumberish): Promise<BigNumber>;

        tokenByIndex(index: BigNumberish): Promise<BigNumber>;

        ownerOf(tokenId: BigNumberish): Promise<BigNumber>;

        balanceOf(owner: string): Promise<BigNumber>;

        setApprovalForAll(to: string, approved: boolean): Promise<BigNumber>;

        isApprovedForAll(owner: string, operator: string): Promise<BigNumber>;

        tokensOfOwner(owner: string): Promise<BigNumber>;

        adminMint(account: string, tokenId: BigNumberish): Promise<BigNumber>;

        withdraw(account: string, tokenId: BigNumberish): Promise<BigNumber>;
    };
}
